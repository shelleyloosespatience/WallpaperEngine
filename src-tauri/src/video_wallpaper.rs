// under development currently so yea debug logs exist heavily and are autogenerated by a plugin
use crate::models::VideoWallpaperState;
use std::fs;
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use tauri::AppHandle;

#[cfg(target_os = "windows")]
use crate::{desktop_injection, wmf_player};

#[cfg(target_os = "linux")]
use wallpaperengine::video_wallpaper_linux;

#[cfg(target_os = "windows")]
use std::{thread, time::Duration};

lazy_static::lazy_static! {
    static ref VIDEO_WALLPAPER_STATE: Arc<Mutex<VideoWallpaperState>> = Arc::new(Mutex::new(VideoWallpaperState {
        is_active: false,
        video_path: None,
        video_url: None,
    }));
}


#[cfg(target_os = "windows")]
lazy_static::lazy_static! {
    static ref WMF_PLAYER_INSTANCE: Arc<Mutex<Option<wmf_player::WmfPlayer>>> = Arc::new(Mutex::new(None));
}

fn get_wallpaper_dir() -> Result<PathBuf, String> {
    let dir = std::env::temp_dir().join("live_wallpapers");
    std::fs::create_dir_all(&dir)
        .map_err(|e| format!("Failed to create wallpaper directory: {}", e))?;
    Ok(dir)
}

fn get_state_file() -> Result<PathBuf, String> {
    let dir = std::env::temp_dir().join("live_wallpapers");
    std::fs::create_dir_all(&dir)
        .map_err(|e| format!("Failed to create wallpaper directory: {}", e))?;
    Ok(dir.join("wallpaper_state.json"))
}

fn save_wallpaper_state(state: &VideoWallpaperState) -> Result<(), String> {
    let state_file = get_state_file()?;
    let json = serde_json::to_string_pretty(state)
        .map_err(|e| format!("failed to serialize state: {}", e))?;

    println!("[state] Saving state to: {:?}", state_file);
    println!(
        "[state] State content: is_active={}, video_path={:?}",
        state.is_active, state.video_path
    );

    fs::write(&state_file, json).map_err(|e| format!("failed to write state file: {}", e))?;
    println!("[state] State saved successfully");
    Ok(())
}

fn load_wallpaper_state() -> Option<VideoWallpaperState> {
    let state_file = match get_state_file() {
        Ok(f) => {
            println!("[state] State file path: {:?}", f);
            f
        }
        Err(e) => {
            println!("[state] Failed to get state file path: {}", e);
            return None;
        }
    };

    if !state_file.exists() {
        println!("[state] State file doesn't exist");
        return None;
    }

    println!("[state] State file exists, reading...");
    match fs::read_to_string(&state_file) {
        Ok(content) => {
            println!("[state] State file content: {}", content);
            match serde_json::from_str(&content) {
                Ok(state) => {
                    println!("[state] State loaded successfully");
                    Some(state)
                }
                Err(e) => {
                    println!("[state] Failed to parse state: {}", e);
                    None
                }
            }
        }
        Err(e) => {
            println!("[state] Failed to read state file: {}", e);
            None
        }
    }
}

pub async fn download_video(url: &str) -> Result<PathBuf, String> {
    let client = reqwest::Client::builder()
        .user_agent("WallpaperApp/1.0")
        .timeout(std::time::Duration::from_secs(300))
        .build()
        .map_err(|e| format!("failed to create HTTP client: {}", e))?;

    let response = client
        .get(url)
        .send()
        .await
        .map_err(|e| format!("failed to download video: {}", e))?;

    if !response.status().is_success() {
        return Err(format!("Server returned error: {}", response.status()));
    }

    let total_size = response.content_length().unwrap_or(0);
    println!("downloading {} bytes...", total_size);

    let bytes = response
        .bytes()
        .await
        .map_err(|e| format!("Failed to read video data: {}", e))?;

    if bytes.is_empty() {
        return Err("Downloaded file is empty".to_string());
    }

    let wallpaper_dir = get_wallpaper_dir()?;
    let extension = if url.contains(".mkv") { "mkv" } else { "mp4" };
    let file_name = format!(
        "wallpaper_{}.{}",
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs(),
        extension
    );
    let file_path = wallpaper_dir.join(file_name);

    std::fs::write(&file_path, bytes).map_err(|e| format!("failed to save video file: {}", e))?;

    println!("downloaded to: {:?}", file_path);
    Ok(file_path)
}

pub fn create_video_wallpaper_window(_app: &AppHandle, video_path: &str) -> Result<(), String> {
    if !std::path::Path::new(video_path).exists() {
        return Err(format!("Video file not found: {}", video_path));
    }

    let ext = std::path::Path::new(video_path)
        .extension()
        .and_then(|s| s.to_str())
        .unwrap_or("");

    if !matches!(ext, "mp4" | "mkv") {
        return Err(format!("Unsupported format: {}. Use MP4 or MKV", ext));
    }

    println!("[main] setting video wallpaper: {}", video_path);

    #[cfg(target_os = "windows")]
    {
        create_windows_wmf_wallpaper(video_path)?;
    }

    #[cfg(target_os = "linux")]
    {
        video_wallpaper_linux::create_linux_video_wallpaper(video_path)?;
    }

    #[cfg(not(any(target_os = "windows", target_os = "linux")))]
    {
        return Err("Video wallpapers not supported on this platform".into());
    }

    // Update state
    let mut state = VIDEO_WALLPAPER_STATE.lock().unwrap();
    state.is_active = true;
    state.video_path = Some(video_path.to_string());
    state.video_url = Some(format!("file://{}", video_path));
    let _ = save_wallpaper_state(&state);
    drop(state);

    println!("[main] background task: wallpaper created successfully");
    Ok(())
}

#[cfg(target_os = "windows")]
fn create_windows_wmf_wallpaper(video_path: &str) -> Result<(), String> {
    let video_path_abs = std::fs::canonicalize(video_path)
        .map_err(|e| format!("Failed to resolve video path: {}", e))?;
    let video_path_str = video_path_abs.display().to_string();

    // Lock the player instance
    let mut player_lock = WMF_PLAYER_INSTANCE.lock().unwrap();

    // If player exists, REUSE IT - just swap the video
    if let Some(existing_player) = player_lock.as_mut() {
        println!("[video_wallpaper] Reusing existing player, swapping video...");

        // Reload media engine to clear old video completely
        println!("[video_wallpaper] Recreating media engine...");
        existing_player.reload_media_engine()?;
        thread::sleep(Duration::from_millis(300));

        // Load new video
        println!("[video_wallpaper] Loading new video: {}", video_path_str);
        existing_player.load_video(&video_path_str)?;
        thread::sleep(Duration::from_millis(500));

        // Start playback
        println!("[video_wallpaper] Starting playback...");
        existing_player.play()?;

        println!("[video_wallpaper] Video swapped successfully!");
        drop(player_lock);
        return Ok(());
    }

    // No existing player - create new one (first time only)
    drop(player_lock);

    println!("[video_wallpaper] Creating new WMF player (first time)...");

    let monitors = get_all_monitor_dimensions();
    let (desktop_x, desktop_y, desktop_width, desktop_height) =
        calculate_total_desktop_bounds(&monitors);

    println!(
        "[video_wallpaper] Desktop bounds: {}x{} at ({}, {})",
        desktop_width, desktop_height, desktop_x, desktop_y
    );

    let player = wmf_player::WmfPlayer::new(desktop_width, desktop_height)
        .map_err(|e| format!("Failed to create WMF player: {}", e))?;

    println!("[video_wallpaper] Loading video: {}", video_path_str);
    player.load_video(&video_path_str)?;

    // Wait for video to load properly
    thread::sleep(Duration::from_millis(500));

    let hwnd = player.hwnd();
    println!("[video_wallpaper] Player window created: {:?}", hwnd);

    // Reduce thread priority
    #[cfg(target_os = "windows")]
    {
        use windows::Win32::System::Threading::{
            GetCurrentThread, SetThreadPriority, THREAD_PRIORITY_BELOW_NORMAL,
        };
        unsafe {
            let current_thread = GetCurrentThread();
            let _ = SetThreadPriority(current_thread, THREAD_PRIORITY_BELOW_NORMAL);
        }
    }

    println!("[video_wallpaper] Injecting behind desktop...");
    desktop_injection::inject_behind_desktop(
        hwnd,
        desktop_x,
        desktop_y,
        desktop_width,
        desktop_height,
    )?;

    // Wait for injection to complete
    thread::sleep(Duration::from_millis(400));

    println!("[video_wallpaper] Starting playback...");
    player.play()?;

    // Store the player instance
    *WMF_PLAYER_INSTANCE.lock().unwrap() = Some(player);

    println!("[video_wallpaper] Wallpaper set successfully");
    Ok(())
}

#[cfg(target_os = "windows")]
fn stop_windows_wmf_wallpaper() -> Result<(), String> {
    println!("[video_wallpaper] Stopping Windows WMF wallpaper...");

    // Stop watchdog first
    desktop_injection::stop_watchdog();
    thread::sleep(Duration::from_millis(200));

    // Get and destroy player
    let mut player_lock = WMF_PLAYER_INSTANCE.lock().unwrap();
    if let Some(mut player) = player_lock.take() {
        println!("[video_wallpaper] Shutting down player...");
        player.shutdown();
        drop(player);
        println!("[video_wallpaper] Player destroyed");
    } else {
        println!("[video_wallpaper] No active player to stop");
    }
    drop(player_lock);

    // Extra cleanup time
    thread::sleep(Duration::from_millis(300));

    println!("[video_wallpaper] Cleanup complete");
    Ok(())
}

#[cfg(target_os = "windows")]
fn get_all_monitor_dimensions() -> Vec<MonitorInfo> {
    use windows::core::BOOL;
    use windows::Win32::Foundation::{LPARAM, RECT};
    use windows::Win32::Graphics::Gdi::{
        EnumDisplayMonitors, GetMonitorInfoW, HDC, HMONITOR, MONITORINFO,
    };

    let mut monitors: Vec<MonitorInfo> = Vec::new();

    unsafe {
        extern "system" fn monitor_enum_proc(
            hmonitor: HMONITOR,
            _hdc: HDC,
            _rect: *mut RECT,
            lparam: LPARAM,
        ) -> BOOL {
            unsafe {
                let monitors = &mut *(lparam.0 as *mut Vec<MonitorInfo>);

                let mut monitor_info = MONITORINFO {
                    cbSize: std::mem::size_of::<MONITORINFO>() as u32,
                    ..Default::default()
                };

                if GetMonitorInfoW(hmonitor, &mut monitor_info) != BOOL(0) {
                    let rect = monitor_info.rcMonitor;
                    monitors.push(MonitorInfo {
                        x: rect.left,
                        y: rect.top,
                        width: rect.right - rect.left,
                        height: rect.bottom - rect.top,
                    });
                }
            }
            BOOL(1)
        }

        let _ = EnumDisplayMonitors(
            None,
            None,
            Some(monitor_enum_proc),
            LPARAM(&mut monitors as *mut _ as isize),
        );
    }

    if monitors.is_empty() {
        monitors.push(MonitorInfo {
            x: 0,
            y: 0,
            width: 1920,
            height: 1080,
        });
    }

    monitors
}

#[cfg(target_os = "windows")]
#[derive(Debug, Clone)]
struct MonitorInfo {
    x: i32,
    y: i32,
    width: i32,
    height: i32,
}

#[cfg(target_os = "windows")]
fn calculate_total_desktop_bounds(monitors: &[MonitorInfo]) -> (i32, i32, i32, i32) {
    let min_x = monitors.iter().map(|m| m.x).min().unwrap_or(0);
    let min_y = monitors.iter().map(|m| m.y).min().unwrap_or(0);
    let max_x = monitors.iter().map(|m| m.x + m.width).max().unwrap_or(1920);
    let max_y = monitors
        .iter()
        .map(|m| m.y + m.height)
        .max()
        .unwrap_or(1080);

    (min_x, min_y, max_x - min_x, max_y - min_y)
}

pub fn stop_video_wallpaper(_app: &AppHandle) -> Result<(), String> {
    println!("stopping video wallpaper...");

    #[cfg(target_os = "windows")]
    {
        stop_windows_wmf_wallpaper()?;
    }

    #[cfg(target_os = "linux")]
    {
        video_wallpaper_linux::stop_linux_video_wallpaper()?;
    }

    let mut state = VIDEO_WALLPAPER_STATE.lock().unwrap();
    state.is_active = false;
    state.video_path = None;
    state.video_url = None;
    let _ = save_wallpaper_state(&state);
    drop(state);

    println!("[video_wallpaper] video wallpaper stopped!!");
    Ok(())
}

pub fn get_video_wallpaper_state() -> VideoWallpaperState {
    VIDEO_WALLPAPER_STATE.lock().unwrap().clone()
}

pub fn restore_wallpaper_on_startup(app: &AppHandle) -> Result<(), String> {
    println!("[startup] Attempting to restore wallpaper...");

    if let Some(saved_state) = load_wallpaper_state() {
        if saved_state.is_active {
            if let Some(ref video_path) = saved_state.video_path {
                if std::path::Path::new(video_path).exists() {
                    println!("[startup] Found saved wallpaper, restoring: {}", video_path);
                    std::thread::sleep(std::time::Duration::from_millis(800));

                    match create_video_wallpaper_window(app, video_path) {
                        Ok(_) => {
                            println!("[startup] Video wallpaper restored successfully!");
                            Ok(())
                        }
                        Err(e) => {
                            println!("[startup] Failed to restore wallpaper: {}", e);
                            // clear invalid state
                            let mut state = VIDEO_WALLPAPER_STATE.lock().unwrap();
                            state.is_active = false;
                            state.video_path = None;
                            state.video_url = None;
                            let _ = save_wallpaper_state(&state);
                            Err(e)
                        }
                    }
                } else {
                    println!("[startup] Saved video file not found: {}", video_path);
                    // Clear invalid state
                    let mut state = VIDEO_WALLPAPER_STATE.lock().unwrap();
                    state.is_active = false;
                    state.video_path = None;
                    state.video_url = None;
                    let _ = save_wallpaper_state(&state);
                    Ok(())
                }
            } else {
                println!("[startup] No video path in saved state");
                Ok(())
            }
        } else {
            println!("[startup] No active wallpaper to restore");
            Ok(())
        }
    } else {
        println!("[startup] No saved state found");
        Ok(())
    }
}
